---
姓名：坏坏
学习时间：2020年6月17日
整理时间：2020年6月19日
---

# 复习回顾

- D类地址：224.0.0.0-239.255.255.255
- 所有设备的组播地址：224.0.0.1
- 路由器的组播地址：224.0.0.2
- OSPF使用的组播地址：224.0.0.5
- OSPF的DR、BDR使用：224.0.0.6
- RIP使用的组播地址：224.0.0.9
- PIM使用的组播地址：224.0.0.13

# IP组播基础

- 网络中部署点到多点通信应用时
	* 采用单播方式，网络中传输的信息量与需要该信息的用户量成正比，多份相同内容的信息发送给不同的用户，对信源和网络带宽造成压力
	* 采用广播方式，无需接受信息的主机也将会收到该信息，信息安全得不到保障，且会造成同一网段中信息泛滥
- 组播源只发送一份数据，数据在网络节点间被复制、分发，且只发送给需要该信息的接收者

# 点到多点的应用

## 传统点到多点

- 服务提供端以单个用户为单位提供服务
- 不同用户与服务提供端的通信数据存在差异

## 新型点到多点

- 服务提供端以一组用户为单位提供服务
- 同组用户与服务提供端的通信数据无差异

## 单播部署点到多点存在的问题

- 重复流量过多
- 消耗设备和了链路带宽资源
- 难以保证传输质量

## 广播部署点到多点存在的问题

- 地域范围限制
- 安全性无法保障
- 有偿性无法保障

## 组播部署点到多点的优势

- 无重复流量
- 节省设备与带宽资源
- 安全性高
- 有偿性有保障

# 组播基本架构

- **组播源到路由器**
	* 组播源到第一跳（源端）路由器——组播数据的生成
- **第一跳（源端）路由器到最后一跳（接收端）路由器**（组播网络）
	* 组播数据的转发
- **最后一跳路由器到接收端**
	* 组播数据的接收

![组播基本架构](F:\GitHub\HCIP R&S\组播基础IGMP.assets\组播基本架构.png)

> - 组播源IP和源MAC地址为自身的IP和MAC
> - 组播的目的IP为组播地址（224.0.0.0-239.255.255.255）
> - 组播的目的MAC为
> 	* MAC地址第8位（第一字节的最后一位）为0则为单播地址
> 	* MAC地址第8位为1为组播地址
> 	* MAC地址全F为广播地址

# 组播地址结构组成

## 组播IP地址

- 一个组播IP地址并不表示具体的某台主机，而是一组主机的集合，主机声明加入某组播组即标识自己需要接受目的地址为该组播地址的数据
- IP组播常见模型为ASM模型（任意源组播）和SSM（特定源组播）模型

| 范围 | 含义 |
|:---:|:---|
| 224.0.0.0—224.0.0.255 | 为路由协议预留的永久组地址 |
| 224.0.1.0—231.255.255.255 233.0.0.0—238.255.255.255 | Any-Source临时组播地址（任意源组播） |
| 232.0.0.0—232.255.255.255 | Source-Specific临时组播组地址（特定源组播） |
| 239.0.0.0—239.255.255.255 | 本地管理的Any-Source临时组播组地址 |

> - `224.0.1.0—238.255.255.255`相当于公网地址
> - `239.0.0.0—239.255.255.255`相当于私网地址

## 组播MAC地址

- IPv4组播MAC地址的高24位为0x01005e，第25位为0

**组播IP与MAC的映射**

- 需要组播地址与组播MAC地址的自动映射
- MAC地址的低23bit为组播IP地址的低23bit

![组播IP与MAC的映射](F:\GitHub\HCIP R&S\组播基础IGMP.assets\组播IP与MAC的映射.png)

> - D类（组播）IP地址的前四位固定为1110，IP地址的后23位直接转换为组播的MAC地址
> - IP地址位32位，除去固定的四位不变的IP地址和23位转换为组播MAC的地址，剩余5位，所以有2^5^=32个IP地址对应为同一个组播MAC地址

# IGMP协议原理及配置

- IGMP（Internet Group Management Protocol）因特网组管理协议，TCP/IP协议族中负责IP组播成员管理的协议。用来在接收者和与其直接相邻的组播路由器之间建立、维护组播组成员关系
- 运行在最后一跳路由器到接收端之间
- IGMP协议作用：
	* 主机侧：通过IGMP协议向路由器通告组成员关系
	* 路由器侧：通过IGMP协议维护组成员关系

## IGMPv1

- **普遍组查询与响应**

1. 接收端向外发送IGMP成员关系报告，表明自己要加入的组播组
2. 路由器周期性（60s）向子网内所有的主机（224.0.0.1）普遍组查询报文，以确定需要哪些组播数据
3. 接收端继续回复IGMP成员关系报告，表明还需要接受相关组的数据

- **响应抑制机制**

1. 普遍组查询报文发送后会有最大响应时间（**10s**）
2. 子网内的主机收到普遍查询报文后，会随机取一个0-10s的值
3. 时间到期后，主机会向外发送成员关系报告
4. 成员关系报告不仅会发给路由器，子网内的主机也会收到
5. 其他需要加入相同组的主机收到其他主机的成员关系报告后，不会再发送成员关系报告

**IGMPv1问题：组成员离开**

- 静默离开

1. 当子网内的组成员离开后，路由器发送普遍组查询报文，10s内没有收到指定组的成员关系报告，路由器会停止接受相应组的数据报文
2. 路由器不会删除相应组的表项，**保留130s**
3. 130s后仍然没有收到子网内主机的需要该组的成员关系报告，就会删除该组的表项

**IGMPv1问题：查询器选举**

- 查询器选举依赖于组播路由协议（PIM），IGMPv1没有查询器

1. 普遍组查询由查询器发送
2. PIM协议会在多台路由器中选取DR
3. DR设备成为查询器

> - DR选举：
> 	* 优先级大的为DR
> 	* IP大的为DR

## IGMPv2

- **IGMPv2的改进：组成员离开**

1. 当子网中的主机要离组时，会向224.0.0.2发送离开组消息报文
2. 路由器收到离开组报文后，会向该组地址发送特定组查询（**会发送2次，间隔1s**）
3. 子网内该组的主机收到特定组报文后，发送成员关系报告
4. 路由器如果没有收到该组的成员关系报告，就会删除该组的表项

> - 普遍组查询是查询所有的组
> - 特定组查询只查询特定的组

- **IGMPv2的改进：查询器选举**

1. IGMPv2有独立的查询器选举机制
2. IP地址小的为查询器
3. 非查询器也会收到查询器的普遍组查询报文
4. 非查询器**125s**没有收到查询器的普遍组查询，自身就会成为查询器

## IGMPv3

- 指定源。只接受特定源发送的组播数据

1. 接受端发送成员关系报告，指出希望加入或拒绝的某些组播源发送的数据

## 总结

- IGMP各版本之间的差异

| 机制 | IGMPv1 | IGMPv2 | IGMPv3 |
|:---:|:---:|:---:|:---:|
| 查询器选举 | 依靠其他协议 | 自己选举 | 自己选举 |
| 成员离开方式 | 静默离开 | 主动发送离开报文 | 主动发送离开报文 |
| 特定组查询 | 不支持 | 支持 | 支持 |
| 指定源、组 | 不支持 | 不支持 | 支持 |

## IGMP配置

**实验**：如下拓扑：

![实验拓扑](F:\GitHub\HCIP R&S\组播基础IGMP.assets\实验拓扑.png)


1. R1配置

```bash
----------------------------------------------
# 基础配置
[R1]int g0/0/0
[R1-GigabitEthernet0/0/0]ip ad 192.168.1.254 24
----------------------------------------------
# 配置组播
[R1]multicast routing-enable  //开启组播功能
[R1]int g0/0/0
[R1-GigabitEthernet0/0/0]igmp enable  //默认版本v2
[R1-GigabitEthernet0/0/0]igmp version 1  //修改版本
```

2. PC端配置

```bash
IP:192.168.1.1
NETMASK:255.255.255.0
GATEWAY：192.168.1.254
```

3. 配置IGMPv1

- PC加入组播，使用IGMPv1，输入需要并加入的组播（目的）IP，目的MAC（不用计算，直接点击即可）

![IGMPv1_PC配置](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv1_PC配置.png)

> `undo stp enable`交换机关闭生成树，方便抓包分析

- 报文分析

![IGMPv1_报文分析](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv1_报文分析.png)

- 在R1上查看组，可以看到192.168.1.1请求加入239.1.1.1组

![IGMPv1_R1查看组](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv1_R1查看组.png)

> IGMPv1没有普遍组查询

- 在R1上配置pim，查看报文

```bash
[R1]int g0/0/0
[R1-GigabitEthernet0/0/0]undo igmp enable  //关闭IGMP
[R1-GigabitEthernet0/0/0]pim dm  //配置pim
[R1-GigabitEthernet0/0/0]igmp enable  //开启IGMP
[R1-GigabitEthernet0/0/0]igmp version 1  //使用IGMPv1
```

![IGMPv1_配置pim报文](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv1_配置pim报文.png)

> - 配置pim前需要先关闭igmp
> - 通过运行pim，路由器会成为查询器，发送普遍组查询报文

4. 配置IGMPv2

```bash
# 关闭pim
[R1-GigabitEthernet0/0/0]undo igmp enable 
[R1-GigabitEthernet0/0/0]undo pim dm
# 使用IGMPv2
[R1-GigabitEthernet0/0/0]igmp enable 
[R1-GigabitEthernet0/0/0]igmp version 2
```

- 查看运行IGMP的接口信息

![IGMPv2_R1查看接口](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv2_R1查看接口.png)

> IGMPv2不需要运行pim，就会有查询器

- PC使用v2版本，加入239.1.11.1组，查看IGMP组即相关报文

![IGMPv2_R1查看组](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv2_R1查看组.png)

- 加组后在PC上离组，查看报文

![IGMPv2_离组报文](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv2_离组报文.png)

5. 配置IGMPv3

- PC端配置v3

![IGMPv3_PC端配置](F:\GitHub\HCIP R&S\组播基础IGMP.assets\IGMPv3_PC端配置.png)

| 类型 | 说明 |
|:---:|:---:|
| MODE_IS_INCLUDE | 增加 |
| MODE_IS_EXCLUDE | 排除 |
| CHANGE_TO_INCLUDE | 改变为增加 |
| CHANGE_IS_EXCLUDE | 改变为排除 |
| ALLOW_NEW_SOURCE | 允许新的源 |
| BLOCK_OLD_SOURCE | 删除某源 |

- IGMP路由表项
	* （S，G）表项：特定的源发往特定的组
	* （*，G）表项：任意源发往特定的组

## IGMP Snooping

- 二层中组播数据转发的问题：
	* 组播数据在二层被泛洪
	* 网络资源浪费
	* 存在安全隐患

- IGMP Snooping原理：
	* 通过侦听组播路由器与主机之间交互的IGMP报文建立组播数据报文的二层转发表项，从而管理和控制组播数据报文在二层网络中的转发

![二层交换机收到数据帧后的处理](F:\GitHub\HCIP R&S\组播基础IGMP.assets\二层交换机收到数据帧后的处理.png)

- 主机发送成员关系报告报文，交换机会将发送相同目的MAC报文的端口划分到同一组
- 交换机接收到来自目的MAC的数据报文，直接转发给相应的端口，其他的端口不会收到该数据报文

> - 路由器有0接口，交换机也有，但是交换机的0口留给CPU
> - 运行IGMP Snooping后，不会存在响应抑制机制

[【PIM】](https://blog.csdn.net/qq_45668124/article/details/106879431)